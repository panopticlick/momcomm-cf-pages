import { type CollectionConfig, APIError } from 'payload'
import { GetBrowseNodes } from '../services/amazon-paapi-edge'
import { convertToSlug } from '../utilities/convert-to-slug'

export const Node: CollectionConfig = {
  slug: 'nodes',
  admin: {
    useAsTitle: 'display_name',
    listSearchableFields: ['display_name', 'slug'],
    components: {
      views: {
        list: {
          Component: './components/payload/node-tree-view#NodeTreeView',
        },
      },
    },
  },
  access: {
    update: () => true,
  },
  endpoints: [
    {
      path: '/:id/add-children',
      method: 'post',
      handler: async (req) => {
        const { id } = req.routeParams as { id: string }
        if (!id) return Response.json({ error: 'Missing ID' }, { status: 400 })

        try {
          const node = await req.payload.findByID({
            collection: 'nodes',
            id,
          })

          if (!node || !node.node_id) {
            return Response.json({ error: 'Node not found or missing node_id' }, { status: 404 })
          }

          const accessKey = process.env.PAAPI_ACCESS_KEY
          const secretKey = process.env.PAAPI_SECRET_KEY
          const partnerTag = process.env.PAAPI_PARTNER_TAG

          if (!accessKey || !secretKey || !partnerTag) {
            return Response.json({ error: 'Missing PAAPI credentials' }, { status: 500 })
          }

          const response = await GetBrowseNodes(
            {
              AccessKey: accessKey,
              SecretKey: secretKey,
              PartnerTag: partnerTag,
              Marketplace: 'www.amazon.com',
            },
            {
              BrowseNodeIds: [node.node_id],
              Resources: ['BrowseNodes.Children'],
            },
          )

          if (
            response &&
            response.BrowseNodesResult &&
            response.BrowseNodesResult.BrowseNodes &&
            response.BrowseNodesResult.BrowseNodes.length > 0
          ) {
            const nodeInfo = response.BrowseNodesResult.BrowseNodes[0]
            const children = nodeInfo.Children || []

            let addedCount = 0
            let updatedCount = 0
            let existingCount = 0

            for (const child of children) {
              const existing = await req.payload.find({
                collection: 'nodes',
                where: {
                  node_id: { equals: child.Id },
                },
                limit: 1,
              })

              if (existing.docs.length === 0) {
                await req.payload.create({
                  collection: 'nodes',
                  data: {
                    node_id: child.Id,
                    display_name: child.DisplayName,
                    context_free_name: child.ContextFreeName,
                    is_root: child.IsRoot || false,
                    parent: node.node_id,
                    slug: '', // Will be auto-generated by beforeValidate hook
                  },
                })
                addedCount++
              } else {
                // Update parent if it's missing or different
                const existingDoc = existing.docs[0]
                if (existingDoc.parent !== node.node_id) {
                  await req.payload.update({
                    collection: 'nodes',
                    id: existingDoc.id,
                    data: {
                      parent: node.node_id,
                    },
                  })
                  updatedCount++
                } else {
                  existingCount++
                }
              }
            }
            return Response.json({
              success: true,
              count: addedCount,
              updated: updatedCount,
              existing: existingCount,
            })
          }

          return Response.json({
            success: true,
            count: 0,
            updated: 0,
            existing: 0,
            message: 'No children found',
          })
        } catch (error) {
          req.payload.logger.error({ msg: 'Error adding children', error })
          return Response.json(
            { error: error instanceof Error ? error.message : 'Unknown error' },
            { status: 500 },
          )
        }
      },
    },
  ],
  hooks: {
    beforeValidate: [
      async ({ data, req }) => {
        // Guard: if no data (e.g., delete operation), skip validation
        if (!data) return data
        // Skip validation for delete operations to avoid errors when node_id is missing
        if (req?.method?.toLowerCase() === 'delete') {
          return data
        }
        if (!data?.node_id) return data

        // If data is already populated (e.g. from recursive creation or manual input), skip API
        if (data.display_name && data.context_free_name) return data

        const accessKey = process.env.PAAPI_ACCESS_KEY
        const secretKey = process.env.PAAPI_SECRET_KEY
        const partnerTag = process.env.PAAPI_PARTNER_TAG

        if (!accessKey || !secretKey || !partnerTag) {
          req.payload.logger.warn('Missing PAAPI credentials, skipping Node auto-population')
          return data
        }

        try {
          const response = await GetBrowseNodes(
            {
              AccessKey: accessKey,
              SecretKey: secretKey,
              PartnerTag: partnerTag,
              Marketplace: 'www.amazon.com',
            },
            {
              BrowseNodeIds: [data.node_id],
              // Resources: ['BrowseNodes.Children'],
            },
          )

          if (
            response &&
            response.BrowseNodesResult &&
            response.BrowseNodesResult.BrowseNodes &&
            response.BrowseNodesResult.BrowseNodes.length > 0
          ) {
            const nodeInfo = response.BrowseNodesResult.BrowseNodes[0]

            data.display_name = nodeInfo.DisplayName
            data.context_free_name = nodeInfo.ContextFreeName
            data.is_root = nodeInfo.IsRoot

            // Store children in req.context to be used in afterChange
            if (!req.context) req.context = {}
          } else {
            req.payload.logger.warn(`No BrowseNode found for ID: ${data.node_id}`)
            throw new APIError(`Invalid Node ID: ${data.node_id} not found in Amazon PAAPI`, 400)
          }
        } catch (error) {
          req.payload.logger.error({ msg: 'Error fetching BrowseNode details', error })
          // If it's already an APIError, rethrow it. Otherwise wrap it.
          if (error instanceof APIError) throw error
          throw new APIError(
            `Failed to validate Node ID: ${error instanceof Error ? error.message : 'Unknown error'}`,
            500,
          )
        }

        return data
      },
      async ({ data, req, originalDoc }) => {
        let incomingData = data
        if (!incomingData && originalDoc) {
          incomingData = {}
        }

        if (!incomingData) return data

        const name = incomingData.display_name || originalDoc?.display_name
        const parentId = incomingData.parent || originalDoc?.parent

        if (name) {
          const localSlug = convertToSlug(name)

          if (parentId) {
            try {
              const parentDocs = await req.payload.find({
                collection: 'nodes',
                where: {
                  node_id: { equals: parentId },
                },
                limit: 1,
                depth: 0,
              })

              if (parentDocs.docs.length > 0) {
                const parentSlug = (parentDocs.docs[0] as { slug?: string }).slug
                if (parentSlug) {
                  incomingData.slug = `${parentSlug}/${localSlug}`
                } else {
                  incomingData.slug = localSlug // Parent has no slug, fallback to local
                }
              } else {
                incomingData.slug = localSlug // Parent not found
              }
            } catch (error) {
              req.payload.logger.error({
                msg: 'Error fetching parent node for slug generation',
                error,
              })
              incomingData.slug = localSlug
            }
          } else {
            incomingData.slug = localSlug
          }
        }

        return incomingData
      },
    ],
    afterChange: [
      async ({ req }) => {
        const children = req.context?.foundChildren as
          | Array<{
              node_id: string
              display_name: string
              context_free_name: string
              is_root: boolean
              parent: string
            }>
          | undefined
        if (children && children.length > 0) {
          for (const child of children) {
            try {
              const existing = await req.payload.find({
                collection: 'nodes',
                where: {
                  node_id: { equals: child.node_id },
                },
                limit: 1,
              })

              if (existing.docs.length === 0) {
                await req.payload.create({
                  collection: 'nodes',
                  data: child as never,
                })
                req.payload.logger.info(`Created child node: ${child.node_id}`)
              }
            } catch (e) {
              req.payload.logger.error(`Failed to create child node ${child.node_id}: ${e}`)
            }
          }
        }
      },
    ],
    beforeDelete: [
      async ({ req, id }) => {
        // 1. Fetch the node to get its node_id (Amazon ID)
        const node = await req.payload.findByID({
          collection: 'nodes',
          id: String(id),
        })

        if (!node || !node.node_id) {
          // If node doesn't exist or has no node_id, let it proceed (or it will fail elsewhere)
          return
        }

        // 2. Check if there are any children (nodes where parent === node.node_id)
        const children = await req.payload.find({
          collection: 'nodes',
          where: {
            parent: { equals: node.node_id },
          },
          limit: 1, // We only need to know if at least one exists
        })

        if (children.docs.length > 0) {
          throw new APIError(
            'Cannot delete node that has children. Please delete children first.',
            400,
          )
        }

        // Delete related NodeTopic records
        try {
          await req.payload.delete({
            collection: 'node-topics',
            where: {
              node: { equals: id },
            },
          })
        } catch (error) {
          req.payload.logger.error({ msg: 'Error deleting related node-topics', error })
        }
      },
    ],
  },
  fields: [
    {
      name: 'node_id',
      type: 'text',
      required: true,
      unique: true,
      index: true,
      admin: {
        description: 'Unique node identifier',
      },
    },
    {
      name: 'display_name',
      type: 'text',
      required: true, // Optional to allow auto-population
      admin: {
        description: 'Display name for the node',
        readOnly: true, // Suggest that this is auto-filled
      },
    },
    {
      name: 'context_free_name',
      type: 'text',
      required: true,
      admin: {
        description: 'Context-free name',
        readOnly: true,
      },
    },
    {
      name: 'parent',
      type: 'text',
      index: true,
      admin: {
        description: 'Parent node identifier',
        readOnly: true,
      },
    },
    {
      name: 'is_root',
      type: 'checkbox',
      admin: {
        description: 'Is root node',
        readOnly: true,
      },
    },
    {
      name: 'slug',
      type: 'text',
      index: true,
      required: true,
      admin: {
        description: 'Auto-generated slug (parent/current)',
        readOnly: true,
      },
    },
    {
      name: 'topics_count',
      type: 'number',
      index: true,
      admin: {
        description: 'Number of topics associated with this node',
        readOnly: true,
      },
    },
  ],
}
